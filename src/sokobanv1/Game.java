/*
 * 21005686
 * Object Oriented Programming
 */
package sokobanv1;

import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import javax.swing.JLabel;
import java.util.HashMap;
import javax.swing.ImageIcon;

/**
 *
 * @author Owen Ross
 */
public class Game extends javax.swing.JFrame implements KeyListener {   //01:53 on final vid: https://brightspace.uhi.ac.uk/d2l/le/content/374391/viewContent/3389172/View

    private JLabel [][] myElements = new JLabel[12][12];
    private Map tmpMap;
    private HashMap<String, ImageIcon> imageHashMap;
    //boolean hasWon = false;
    private boolean levelComplete;
    private int level;
    private String[] mapNames = {"/SokobanMaps/level1.txt", "/SokobanMaps/level2.txt", "/SokobanMaps/level3.txt", "/SokobanMaps/level4.txt", "/SokobanMaps/level5.txt"};

    /**
     *  This starts a new instance of the game, initialising the graphical representation of the game, handling the user input, tracking the level the user is on and holding the mapNames array, which is the filenames of the maps
     */
    public Game() {
        initComponents();
        String[] mapNames = {"/SokobanMaps/level1.txt", "/SokobanMaps/level2.txt", "/SokobanMaps/level3.txt", "/SokobanMaps/level4.txt", "/SokobanMaps/level5.txt"};
        int level;
        
        imageHashMap = new HashMap<>();
        for (int i = 0; i < myElements.length; i++) { //When working with graphics, use myElements
            for (int j = 0; j < myElements.length; j++) {
                myElements[i][j] = new JLabel();
                //myElements[i][j].setText(".");
                pnl_game.add(myElements[i][j]);
                
            }
            
        }
        
        
        
        level = 0;
        this.addKeyListener(this);
        setFocusable(true);
        tmpMap = new Map(mapNames[level]); //maybe pass map names and level through here?
        drawMap();
    }

    /**
     *
     * @return mapNames array
     */
    public String[] getMapNames() {
        return mapNames;
    }
    
    /**
     *
     * @return
     */
    public boolean isLevelComplete() {
        return levelComplete;
    }

    /**
     *
     * @param filename
     * @return
     */
   

    /**
     *
     * @return imageHashMap. This acts as the getter for the hashmap, allowing methods to populate it and access its contents
     */
    public HashMap<String, ImageIcon> getImageHashMap() {
        return imageHashMap;
    }

    //public void setImageHashMap(HashMap<String, ImageIcon> imageHashMap) {
      //  this.imageHashMap = imageHashMap;
    //}

    /**
     *
     * @param filepath - is the filepath for each sprite used in the game
     */

    public void populateHashMap(String filepath){
        if (imageHashMap.containsKey(filepath)){
            //lbl_output2.setText("Image already in memory");
        } else {
            //imageHashMap.put(filepath, new ImageIcon((getClass().getResource(tmpMap.getMyMap()[i][j].getImgFileName()))));
            imageHashMap.put(filepath, new ImageIcon(getClass().getResource(filepath)));
            //lbl_output2.setText("Image added to memory");
        }
    
    }
    
    
    

    
    
    
    
    private void drawMap(){
        for (int i = 0; i < myElements.length; i++) {
            for (int j = 0; j < myElements.length; j++) {
                //myElements[i][j].setText(tmpMap.getMyMap()[i][j].getSymbol());            
                //myElements[i][j].setIcon(new ImageIcon(getClass().getResource(tmpMap.getMyMap()[i][j].getImgFileName())));
               
                if(tmpMap.getMyMap()[i][j] != null){
                    populateHashMap(tmpMap.getMyMap()[i][j].getImgFileName());
                    myElements[i][j].setIcon(imageHashMap.get(tmpMap.getMyMap()[i][j].getImgFileName()));
                }
            } 
        }
     }
    
    
    
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        pnl_status = new javax.swing.JPanel();
        lbl_output = new javax.swing.JLabel();
        lbl_output2 = new javax.swing.JLabel();
        pnl_game = new javax.swing.JPanel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        pnl_status.setPreferredSize(new java.awt.Dimension(400, 30));

        lbl_output.setText("Movement and victory info here");

        lbl_output2.setText("Hashmap info here");

        javax.swing.GroupLayout pnl_statusLayout = new javax.swing.GroupLayout(pnl_status);
        pnl_status.setLayout(pnl_statusLayout);
        pnl_statusLayout.setHorizontalGroup(
            pnl_statusLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(pnl_statusLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(lbl_output, javax.swing.GroupLayout.DEFAULT_SIZE, 261, Short.MAX_VALUE)
                .addGap(18, 18, 18)
                .addComponent(lbl_output2, javax.swing.GroupLayout.PREFERRED_SIZE, 97, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );
        pnl_statusLayout.setVerticalGroup(
            pnl_statusLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(pnl_statusLayout.createSequentialGroup()
                .addGroup(pnl_statusLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(lbl_output, javax.swing.GroupLayout.DEFAULT_SIZE, 18, Short.MAX_VALUE)
                    .addComponent(lbl_output2))
                .addContainerGap())
        );

        getContentPane().add(pnl_status, java.awt.BorderLayout.PAGE_END);

        pnl_game.setPreferredSize(new java.awt.Dimension(400, 400));
        pnl_game.setLayout(new java.awt.GridLayout(12, 12));
        getContentPane().add(pnl_game, java.awt.BorderLayout.CENTER);

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Game.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Game.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Game.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Game.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Game().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel lbl_output;
    private javax.swing.JLabel lbl_output2;
    private javax.swing.JPanel pnl_game;
    private javax.swing.JPanel pnl_status;
    // End of variables declaration//GEN-END:variables

    /**
     *
     * @param e
     */
    @Override
    public void keyTyped(KeyEvent e) {}

    /**
     *
     * @param e
     */
    @Override
    public void keyPressed(KeyEvent e) {
       
        levelComplete = tmpMap.checkForWin();
        
        if(e.getKeyChar() == 'w' || e.getKeyCode() == KeyEvent.VK_UP){
             if(levelComplete != false){
                tmpMap.readMap(getMapNames()[level]);
            } else {
                tmpMap.movePlayer(1);
                lbl_output.setText("You pressed up");}
        } else if (e.getKeyChar() == 's'|| e.getKeyCode() == KeyEvent.VK_DOWN) {
                 if(levelComplete != false){
                     tmpMap.readMap(getMapNames()[level]);
            } else {
                tmpMap.movePlayer(2);
                lbl_output.setText("You pressed down");}
        } else if (e.getKeyChar() == 'a'|| e.getKeyCode() == KeyEvent.VK_LEFT) {
             if(levelComplete != false){
                tmpMap.readMap(getMapNames()[level]);
            } else {
                tmpMap.movePlayer(3);
                lbl_output.setText("You pressed left");}
        } else if (e.getKeyChar() == 'd'|| e.getKeyCode() == KeyEvent.VK_RIGHT) {
             if(levelComplete != false){
                tmpMap.readMap(getMapNames()[level]);
            } else {
                tmpMap.movePlayer(4);
                lbl_output.setText("You pressed Right");}
        }  else if (e.getKeyCode() == KeyEvent.VK_SPACE) {
            if(levelComplete != false){
                tmpMap.readMap(getMapNames()[level]);
            } else{
                tmpMap.resetMap(getMapNames()[level]);
            }
        }
        //tmpMap.checkForWin();
        //boolean hasWon = tmpMap.checkForWin();
        //System.out.println(hasWon);
         if (tmpMap.checkForWin()){
            lbl_output.setText("You have won this level! Please press spacebar for next level");
            //levelComplete = true;
            level++;
                if(level == getMapNames().length){
                    System.out.println("You won the game!");
                    System.exit(0);
                }
            System.out.println(levelComplete);
        }


        
        drawMap();
        
        //System.out.println(tmpMap.checkForWin());
        
        /*
        if (tmpMap.checkForWin()){
            lbl_output.setText("You have won!");
            levelComplete = true;
            level++;
            System.out.println(levelComplete);
        }*/
    }

    /**
     *
     * @param e
     */
    @Override
    public void keyReleased(KeyEvent e) {}
}
